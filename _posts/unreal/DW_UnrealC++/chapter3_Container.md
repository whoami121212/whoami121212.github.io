
TArray
add보다 emplace를 사용하는 것이 더 좋다. 
append : 한 번에 다수의 객체를 집어넣을 때. 
AddUnique도 있는데, 이걸 사용할 바에는 set을 사용하는 것이 더 좋다. 

모든 for문 사용이 가능하다. ranged for도 사용가능. const를 사용하면 읽기전용 순회가 일어나게 된다. 

중요한 쿼리 : 
- GetData 인자를 얻어온 다음 인덱스를 이용해서 원하는 엘리먼트를 바로 접근할 수 있음. 
반환된다고 설명할 수 있다. 기본적인 함수들이기 때문에 그냥 넘어가면 된다. 

RemoveSingle : 배열에서 처음 일치한 엘리먼트를 지우는 것 
RemoveAt : 함수로 제거할 엘리먼트를 0부터 시작하는 인덱스로 

이진힙에 대해서 공부하고 올 것. 

슬랙이라는 것은 남아있으면 낭비가 될 수 있기 때문에 제거해서 깔끔하게 정리를 할 수 있다는 것. 

초기화를 하지 않기 때문에 필요한 메모리만 할당할 수 있다. 

예제를 통해서 다뤄보기로 시릅  슬랙을 제거해주는 함수도 있다. 
커스텀 구조체를 이용하는 경우에는 맵을 다룰 때 선언해서 셋이나 맵을 사용할 때 어떻게 함수를 구현해야하는지 알아보도록 하자. 
정말 특이한 경우라고 볼 수 있는데 세트에 대해서 정말로 커스터마이징을 해서 다양한 형태를 만들고싶다면? 마지막이고요. 


Unreal Container Library II - Struct & Map 
- 구조체의 선언과 이해 
- TMap의 내부 구조의 이해 
- 장단점을 파악하고 알맞게 활용

구조체 Struct 
UStruct : Property를 체계화 및 조작할 수 있는 데이터 구조체 

구조체 구현 
1. 정의하려는 헤더를 연다. 
2. C++ 구조체를 정의하고 앞에 USTRUCT 매크로를 추가한다. 구조체에 필요한 모든 UStruct 지정자를 포함한다. 
3. 구조체 상단에 GENERATED_BODY 매크로를 추가한다. 
4. 구조체의 멤버변수를 UPROPERTY로 태그하여 언리얼 엔진의 리플렉션 시스템과 블루프린트 스크립팅에 표시할 수 있다. 

UStruct의 특징 
- 데이터 저장/전송에 특화된 가벼운 객체 
- 대부분 GENERATED_BODY 매크로를 선언해준다. 
    - 리플렉션, 직렬화와 같은 유용한 기능을 제공
    - GENERATED_BODY를 선언한 구조체는 UScriptStruct 클래스로 구현된다. 
    - 이 경우 제한적으로 리플렉션을 지원한다. 속성 UPROPERTY만 선언할 수 있고, 함수 UFUNCTION은 선언할 수 없다. 
- 언리얼 엔진의 구조체 이름은 F로 시작한다. 
    - 대부분 힙 메모리 할당(포인터 연산)없이 스택 내 데이터로 사용된다. 
    - NewObject API를 사용할 수 없다. 

```c++
USTRUCT(Blueprint Type)
struct FMyStruct 
{
    GENERATED_BODY()

    // 블루프린트 그래프를 통해서 액세스 할 수 있음. 
    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category="Test Variables")
    int32 MyIntegerMemberVariable;

    // 블루프린트 그래프를 통해서 액세스 할 수 없음. 
    int32 NativeOnlyMemberVariable;
}

```

## TMap 
- 내부적으로 TSet과 동일한 구조를 가지고 있음. 
- Key / Value 구성의 Tuple 데이터 이용
- 삭제해도 재구축은 일어나지 않지만 비어있는 메모리가 발생할 수는 있다. 
- Key 중복이 허용되지 않음. 
    - 중복이 필요할 때에는 TMultiMap을 사용하면 관리할 수 있음. 

- memo : 집합처럼 추가해서 넣을 수 있다. 에디터와 연동해서 이것들을 쉽게 반복처리도 동일하고, 이터레이터를 지원한다. find / add가 있는데 그것만 명확하게 사용하면 된다. 
기본적으로는 복사 생성을 할 수 있고 슬랙도 셋과 동일하다. 중간중간 여유분이 있기 때문에 

- KeyFuncs 다른 유니크값이 만들어지도록 설계값이 같더라도 유니크가 다르면 같은 값이라고 볼 수 없다.  

##  메모리관리 
- 포인터를 관리하는 방법의 학습 


## 자동 메모리 관리 시스템 
- 1. new - delete 짝을 맞추는 어려움. (메모리 누수)
- 2. 무효된 곳을 가리키는 포인터 (댕글링 포인터)
- 3. 값이 초기화되지 않아서 엉뚱한 주소를 가리킴 (와일드 포인터) 
- 규모가 커질수록 실수할 확률이 크게 증가함. 포인터를 버리고 가비지 컬렉션시스템을 도입한 이유 

- 언리얼에서는 지정된 주기마다 없애도록 설정되어 있음. 기본적으로는 60초. 
- 병렬처리, 클러스터링과 같은 기능을 탑재하여 성능을 챙김. 
- GUObjectArray 모든 언리얼 오브젝트의 정보를 저장함. 
- Flag를 설정하여 삭제할 오브젝트인지 아닌지 판단. 플래그는 시스템이 알아서 설정한다. 

## Unreal Object의 관리 원칙 
- 생성된 오브젝트를 유지하기 위해서 레퍼런스 참조 방법을 설계 
    - 언리얼 오브젝트 내의 언리얼 오브젝트 : UPROPERTY사용 
    - 일반 C++오브젝트 내의 언리얼 오브젝트 : FGCObject의 상속 후 구현 
- 생성된 언리얼 오브젝트는 강제로 지우려 하지 말 것 
    - 참조를 끊는다는 생각으로 설계
    - ForceGarbageCollection을 이용해서 메모리를 회수하도록 재촉할 수는 있음. 
    - Destroy 함수를 사용할 수 있으나, 내부 동작은 가비지 콜렉터에게 위임하는 방식으로 동일함. 

## GC 사이클 변경 Garbage Collector Cycle
- 프로젝트 세팅 -> Garbage Collection 
- GC 사이클을 3초로 변경한 후에 테스트해보면, 
    - UPROPERTY가 붙어있는 포인터는 정상적으로 유효하게 동작하지만, 
    - UPROPERTY가 없는 포인터는 null은 아니지만 유효하지 않은 포인터로 동작하게 된다.
    - TArray 등의 자료구조에 UObjectPtr을 넣는 경우에도 동일하게 작동한다. 
- 즉, UObject의 포인터를 안전하게 보관하기 위해서는 UPROPERTY를 반드시 붙여주어야 한다. 

## 일반 C++ class는 어떻게 관리해야 하는가? 

아니 슈발 너무 어려운데? ㅋㅋㅋㅋ 이걸 내가 어떻게 하지 